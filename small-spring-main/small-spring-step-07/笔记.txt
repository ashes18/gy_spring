--01——创建简单的Bean容器
// 1.初始化 BeanFactory
BeanFactory beanFactory = new BeanFactory();

// 2.注册 bean
BeanDefinition beanDefinition = new BeanDefinition(new UserService());
beanFactory.registerBeanDefinition("userService", beanDefinition);

// 3.获取 bean
UserService userService = (UserService) beanFactory.getBean("userService");
userService.queryUserInfo();

定义：BeanDefinition，可能这是你在查阅 Spring 源码时经常看到的一个类，例如它会包括 singleton、prototype、BeanClassName 等。
但目前我们初步实现会更加简单的处理，只定义一个 Object 类型用于存放对象。
注册：这个过程就相当于我们把数据存放到 HashMap 中，只不过现在 HashMap 存放的是定义了的 Bean 的对象信息。
获取：最后就是获取对象，Bean 的名字就是key，Spring 容器初始化好 Bean 以后，就可以直接获取了。


-- 02（模板模式）——实现bean的定义、注册、获取
接口定义了注册，抽象类定义了获取，都集中在 DefaultListableBeanFactory 中的 beanDefinitionMap 里

// 1.初始化 BeanFactory
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();

// 2.注册 bean
//在 Bean 注册的时候只注册一个类信息，而不会直接把实例化信息注册到 Spring 容器中
BeanDefinition beanDefinition = new BeanDefinition(UserService.class);
beanFactory.registerBeanDefinition("userService", beanDefinition);

// 3.第一次获取 bean
UserService userService = (UserService) beanFactory.getBean("userService");
userService.queryUserInfo();

// 4.第二次获取 bean from Singleton
//检验当前单例对象在容器中是否已经缓存起来
UserService userService_singleton = (UserService) beanFactory.getSingleton("userService");
userService_singleton.queryUserInfo();

public Object getBean(String name) throws BeansException {
    //继承了 DefaultSingletonBeanRegistry，也就具备了使用单例注册类方法
    //先看缓存有没有
    Object bean = getSingleton(name);
    if (bean != null) {
        return bean;
    }

    //获取不到时需要拿到 Bean 的定义做相应 Bean 实例化操作
    //getBean 并没有自身的去实现这些方法，而是只定义了调用过程以及提供了抽象方法，由实现此抽象类的其他类做相应实现
    BeanDefinition beanDefinition = getBeanDefinition(name);
    return createBean(name, beanDefinition);
}

protected Object createBean(String beanName, BeanDefinition beanDefinition) throws BeansException {
    Object bean;
    try {
        //实现了 Bean 的实例化操作 newInstance，其实这块会埋下一个坑，有构造函数入参的对象怎么处理？可以提前思考
        bean = beanDefinition.getBeanClass().newInstance();
    } catch (InstantiationException | IllegalAccessException e) {
        throw new BeansException("Instantiation of bean failed", e);
    }

    //在处理完 Bean 对象的实例化后，直接调用 addSingleton 方法存放到单例对象的缓存中去
    addSingleton(beanName, bean);
    return bean;
}

--03（策略模式）——基于Cglib实现含构造函数的类实例化策略

protected Object createBeanInstance(BeanDefinition beanDefinition, String beanName, Object[] args) {
    Constructor constructorToUse = null;
    Class<?> beanClass = beanDefinition.getBeanClass();
    Constructor<?>[] declaredConstructors = beanClass.getDeclaredConstructors();
    for (Constructor ctor : declaredConstructors) {
        if (null != args && ctor.getParameterTypes().length == args.length) {
            constructorToUse = ctor;
            break;
        }
    }
    //策略模式，基于Cglib实现含构造函数的类实例化策略
    return getInstantiationStrategy().instantiate(beanDefinition, beanName, constructorToUse, args);
}


--04(递归、考虑循环依赖怎么解决)——注入属性和依赖对象
protected void applyPropertyValues(String beanName, Object bean, BeanDefinition beanDefinition) {
        try {
            PropertyValues propertyValues = beanDefinition.getPropertyValues();
            for (PropertyValue propertyValue : propertyValues.getPropertyValues()) {

                String name = propertyValue.getName();
                Object value = propertyValue.getValue();

                if (value instanceof BeanReference) {
                    // A 依赖 B，获取 B 的实例化
                    BeanReference beanReference = (BeanReference) value;
                    /*
                    1、初始化 BeanFactory、2. UserDao 定义注册、3. UserService 设置属性[uId、userDao]、4、serService 注入bean（定义并注册）
                    5、beanFactory.getBean("userService")
                    (1)缓存没有、获取定义，创建bean
                   （2）基于Cglib实现含构造函数的类实例化策略（实例化）
                   （3）给 Bean 填充属性（a、属性填充(uId)b、引用属性填充（getBean("userDao")））
                    */
                    value = getBean(beanReference.getBeanName());
                }
                // 属性填充
                BeanUtil.setFieldValue(bean, name, value);
            }
        } catch (Exception e) {
            throw new BeansException("Error setting property values：" + beanName);
        }
}


-- 05（配置文件的读取、解析）——资源加载器解析文件注册对象
--添加一个资源解析器，也就是能读取classpath、本地文件和云文件的配置内容。这些配置内容就是像使用 Spring 时配置的 Spring.xml 一样，
里面会包括 Bean 对象的描述和属性信息。 在读取配置文件信息后，接下来就是对配置文件中的 Bean 描述信息解析后进行注册操作，
把 Bean 对象注册到 Spring 容器中

// 1.初始化 BeanFactory
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();

// 2. 读取配置文件&注册Bean
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
//处理资源加载，这里新增加了一个内部方法：doLoadBeanDefinitions，它主要负责解析 xml
//在 doLoadBeanDefinitions 方法中，主要是对xml的读取 XmlUtil.readXML(inputStream) 和元素 Element 解析。在解析的过程中通过循环操作，以此获取 Bean 配置以及配置中的 id、name、class、value、ref 信息。
//最终把读取出来的配置信息，创建成 BeanDefinition 以及 PropertyValue，最终把完整的 Bean 定义内容注册到 Bean 容器：getRegistry().registerBeanDefinition(beanName, beanDefinition)
reader.loadBeanDefinitions("classpath:spring.xml");

// 3. 获取Bean对象调用方法
UserService userService = beanFactory.getBean("userService", UserService.class);

AbstractAutowireCapableBeanFactory.createBean
//实例化（定义）bean
bean = createBeanInstance(beanDefinition, beanName, args);
// 给 Bean 填充属性
applyPropertyValues(beanName, bean, beanDefinition);
    if (value instanceof BeanReference) {
    // A 依赖 B，获取 B 的实例化
    BeanReference beanReference = (BeanReference) value;
    //再去getB的bean
    value = getBean(beanReference.getBeanName());

//存放到单例对象的缓存中
addSingleton(beanName, bean);
                    }


--06（自动识别、资源加载、扩展机制）——实现应用上下文
//设计：在 Bean 对象从注册到实例化的过程中执行用户的自定义操作，就需要在 Bean 的定义和初始化过程中插入接口类，这个接口再有外部去实现自己需要的服务
关于 Spring 应用上下文以及对 Bean 对象扩展机制的实现。

主要新增了 Spring 框架中两个非常重要的接口 BeanFactoryPostProcess、BeanPostProcessor 同时还添加了关于应用上下文的实现，
ApplicationContext 接口的定义是继承 BeanFactory 外新增加功能的接口，它可以满足于自动识别、资源加载、容器事件、监听器等功能，
同时例如一些国际化支持、单例Bean自动初始化等，也是可以在这个类里实现和扩充的。

通过本文的实现一定会非常了解 BeanFactoryPostProcess、BeanPostProcessor，以后再做一些关于 Spring 中间件的开发时，
如果需要用到 Bean 对象的获取以及修改一些属性信息，那么就可以使用这两个接口了。同时 BeanPostProcessor 也是实现 AOP 切面技术的关键所在。

以继承了 ListableBeanFactory 接口的 ApplicationContext 接口开始，扩展出一系列应用上下文的抽象实现类，并最终完成 ClassPathXmlApplicationContext 类的实现。而这个类就是最后交给用户使用的类。
同时在实现应用上下文的过程中，通过定义接口：BeanFactoryPostProcessor、BeanPostProcessor 两个接口，把关于对 Bean 的扩展机制串联进去了。

BeanFactoryPostProcessor，是由 Spring 框架组建提供的容器扩展机制，允许在 Bean 对象注册后但未实例化之前，对 Bean 的定义信息 BeanDefinition 执行修改操作。
BeanPostProcessor，也是 Spring 提供的扩展机制，不过 BeanPostProcessor 是在 Bean 对象实例化之后修改 Bean 对象，也可以替换 Bean 对象。这部分与后面要实现的 AOP 有着密切的关系。


// 1.初始化 BeanFactory
//从 XML 中加载 BeanDefinition，并刷新上下文
//refresh()
//1、创建 BeanFactory，并加载 BeanDefinition(获取了 DefaultListableBeanFactory 的实例化以及对资源配置的加载操作
loadBeanDefinitions(beanFactory)，在加载完成后即可完成对 spring.xml 配置文件中 Bean 对象的定义和注册，
同时也包括实现了接口 BeanFactoryPostProcessor、BeanPostProcessor 的配置 Bean 信息。)
//2、获取 BeanFactory
//3、在 Bean 实例化之前，执行 BeanFactoryPostProcessor (Invoke factory processors registered as beans in the context.)
//4、BeanPostProcessor 需要提前于其他 Bean 对象实例化之前执行注册操作
//5、 提前实例化单例Bean对象
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:springPostProcessor.xml");
//beanDefinitionMap有四个值：myBeanPostProcessor、myBeanFactoryPostProcessor、userDao、userService

// 2. 获取Bean对象调用方法
UserService userService = applicationContext.getBean("userService", UserService.class);
String result = userService.queryUserInfo();
System.out.println("测试结果：" + result);



--07——初始化和销毁方法
对于这样在 Bean 容器初始化过程中额外添加的处理操作，无非就是预先执行了一个定义好的接口方法或者是反射调用类中xml中配置的方法，
最终你只要按照接口定义实现，就会有 Spring 容器在处理的过程中进行调用而已。
(目前这个 Spring 框架对 Bean 的操作越来越完善了，可扩展性也不断的增强。你既可以在Bean注册完成实例化前进行 BeanFactoryPostProcessor 操作，
也可以在Bean实例化过程中执行前置和后置操作，现在又可以执行Bean的初始化方法和销毁方法。所以一个简单的Bean对象，已经被赋予了各种扩展能力。)

@Test
public void test_xml() {
    // 1.初始化 BeanFactory
    ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring.xml");
    //注册钩子的动作
    applicationContext.registerShutdownHook();

    // 2. 获取Bean对象调用方法
    UserService userService = applicationContext.getBean("userService", UserService.class);
    String result = userService.queryUserInfo();
    System.out.println("测试结果：" + result);
}

doLoadBeanDefinitions方法Bean属性定义增加初始化和销毁后，还需要在XmlBeanDefinitionReader类中，增加对新增属性的读取，并添加到BeanDefinition中
String initMethod = bean.getAttribute("init-method");
String destroyMethodName = bean.getAttribute("destroy-method");

beanDefinition.setInitMethodName(initMethod);
beanDefinition.setDestroyMethodName(destroyMethodName);

applicationContext.getBean("userService", UserService.class);
getBean先从缓存拿，没有就createBean（1、实例化bean 2、给 Bean 填充属性 3、执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法）
上述3是执行initializeBean方法，包括：
1、执行 BeanPostProcessor Before 处理
2、执行 执行 Bean 对象的初始化方法(invokeInitMethods)
3、执行 执行 BeanPostProcessor After 处理

private void invokeInitMethods(String beanName, Object bean, BeanDefinition beanDefinition) throws Exception {
        // 1. 实现接口 InitializingBean
        if (bean instanceof InitializingBean) {
            //在 BeanFactory 设置属性后作出相应的处理，如：执行自定义初始化，或者仅仅检查是否设置了所有强制属性。
            ((InitializingBean) bean).afterPropertiesSet();
        }

        // 2. 注解配置 init-method {判断是为了避免二次执行初始化}
        String initMethodName = beanDefinition.getInitMethodName();
        if (StrUtil.isNotEmpty(initMethodName) && !(bean instanceof InitializingBean)) {
            Method initMethod = beanDefinition.getBeanClass().getMethod(initMethodName);
            if (null == initMethod) {
                throw new BeansException("Could not find an init method named '" + initMethodName + "' on bean with name '" + beanName + "'");
            }
            //执行反射调用
            initMethod.invoke(bean);
        }
}



销毁适配类（DisposableBeanAdapter）
 @Override
    public void destroy() throws Exception {
        // 1. 实现接口 DisposableBean
        if (bean instanceof DisposableBean) {
            ((DisposableBean) bean).destroy();
        }

        // 2. 注解配置 destroy-method {判断是为了避免二次执行销毁}
        if (StrUtil.isNotEmpty(destroyMethodName) && !(bean instanceof DisposableBean && "destroy".equals(this.destroyMethodName))) {
            Method destroyMethod = bean.getClass().getMethod(destroyMethodName);
            if (null == destroyMethod) {
                throw new BeansException("Couldn't find a destroy method named '" + destroyMethodName + "' on bean with name '" + beanName + "'");
            }
            destroyMethod.invoke(bean);
        }

    }
 JDK提供了Java.Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的钩子，这个钩子可以在一下几种场景中被调用：

 程序正常退出
 使用System.exit()
 终端使用Ctrl+C触发的中断
 系统关闭
 OutOfMemory宕机
 使用Kill pid命令干掉进程（注：在使用kill -9 pid时，是不会被调用的）




